package main

import (
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"net/http"
	"net/url"

	"github.com/crewjam/saml"
	"github.com/crewjam/saml/samlsp"
)

// In a real deployment, this key would need to be set on a per-instance basis (provided via
// config, or generated by Fleet) and kept secret.
var spKey = func() *rsa.PrivateKey {
	b, _ := pem.Decode([]byte(`-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCcVtwj1e6m+Au6
KT3Iex1XY35iWO9vPwkNg2UaEfaGxjE5pzUec9l7tGp1nFY+5ZnuSHChzkalKk9W
IHt9ppIXTr78oF/IOLr6pJOMKG2tbcANlL8DDyKVkAKhxtn1kgDsNfGKOK00M9VJ
6gJG8yHeiugDr9funMD7bb4kBTyLHjZAgJNPu0Au3d/zc80FpqYt8f9t81gp+Cc9
SFZwGSqcuSh8V6V2AMrr0DzEoKkT4mJBcsKo40FFbB/9EgkePbbpnT5f7n3hwysc
oXxzLkS+kAX1PbXMo49pIG6sLJNwwSelPNkFxxOiWHMNrEcqQ7j7BnrHLmEXYlyn
4dE02d+FAgMBAAECggEAGwvc0DdHruuNDdLqLRd9azubZvS3UWHQlV2knTa71TOO
2wg+BItqtb+vxjJ6ai2q7GHsWFW4+4RfDsmWS5XIQs9883PkNh14XXmgy/fHh6AL
wF26ENOqukCcb/PYi6cLUVIAvBaTgkswTDX3WGJh+t/BhTfDzbQhH64r3YvpXjCh
z1+fKLCwLSWaU6GaTBNNo+1xMPypc6EjCImmQ1K/yu884vAs8RmfuqRbiWQ+JGpR
P8ZXR1BC4dEAH8FtZu8YY6IoZF/l5xCeQJlsDTdeGyonco23Q4ad8UCexbEKCrgi
+mgrQbYilQKMZB10zC0IFzKEy9eH6o3ZOMIlxqQroQKBgQDQb2d5P5f9kLG1n8Wr
71+Yd5aD3ksYJAwC6PgwnhTn+F1jCT9JMcrbsy+YpnFGyu+sM2iwRHpyw6AYKI1B
SA54LHLoX3RkuTObn/yg4JiSmxijLDNvEzqGyWIzAXiN0JXxvD3zZApueDduShvw
lsZ9YvdFv5NV8JX/HgocH1qUYQKBgQDABA+2s2nAJubRn7lDNMe00UmASCg4bgul
2MEYNhO/SDG1uBLtWCntEfVQydyM7aS2YVJRtnfC2T/y+OYMnHF/RArmLp9tV0+g
E+78/K6DwQaCPUrVwnBpiEDgi81HBtyXFd0EvNceWz3wgDZ6ymI3U7Kb6RCxiwuG
btuEUTFdpQKBgBSx6vkr6kBf3HUnDu5aTwiJXyVqrdQQyCyFyxawq2y4yTTrFyCC
VBzqNqCWbgrUXWWgmRVfRzUb3UpoxFWl/OHLsAEIcTsK9GfQQ7oJcryjr5eL7PNr
WlVFq31a+QhDnI+q3A/NcAe14fMOYqXJop2SdPC068ENqSbyaZiPOGQhAoGBAJij
Yd5pdtox0nC22K3NCif56sTYF2jsScQXrz/Q1RfMiv+aiSk1WXbEPM9w+CrrSnFU
ofyk4UT6MDS0mSNTRYHWlBdw3nkr2/czgVqIfy3rRoJHuPJ986BgmLonSBJ7KOXN
knmOqC7Qd0d0lFo+AZ9boHMB7axFDO9btpLTfDulAoGAPFqhBJV1bhSYyvJYFsy+
MlTfDoxjReRjdbs20wpOomA1QKbvBs++iAqFg/PLLrKT8Q6xtGQPi+6XPdp/wLuR
a1YiVZxnMNHUyiPdbrEOedgmXAIUXAjuxiIy/u4k+EKb7yTmSgtNJv5nDHeuWelb
oOfhCq1oEroJeSAmytedrrQ=
-----END PRIVATE KEY-----`))
	k, err := x509.ParsePKCS8PrivateKey(b.Bytes)
	if err != nil {
		panic(err)
	}
	return k.(*rsa.PrivateKey)
}()

var spCert = func() *x509.Certificate {
	b, _ := pem.Decode([]byte(`-----BEGIN CERTIFICATE-----
MIIDITCCAgmgAwIBAgIUVViQ87K8F8nGf8tdG8qn6aYBMkQwDQYJKoZIhvcNAQEL
BQAwIDEeMBwGA1UEAwwVbXlzZXJ2aWNlLmV4YW1wbGUuY29tMB4XDTI0MDMxMzE4
MjUzMloXDTI1MDMxMzE4MjUzMlowIDEeMBwGA1UEAwwVbXlzZXJ2aWNlLmV4YW1w
bGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnFbcI9XupvgL
uik9yHsdV2N+Yljvbz8JDYNlGhH2hsYxOac1HnPZe7RqdZxWPuWZ7khwoc5GpSpP
ViB7faaSF06+/KBfyDi6+qSTjChtrW3ADZS/Aw8ilZACocbZ9ZIA7DXxijitNDPV
SeoCRvMh3oroA6/X7pzA+22+JAU8ix42QICTT7tALt3f83PNBaamLfH/bfNYKfgn
PUhWcBkqnLkofFeldgDK69A8xKCpE+JiQXLCqONBRWwf/RIJHj226Z0+X+594cMr
HKF8cy5EvpAF9T21zKOPaSBurCyTcMEnpTzZBccTolhzDaxHKkO4+wZ6xy5hF2Jc
p+HRNNnfhQIDAQABo1MwUTAdBgNVHQ4EFgQUYxvp8EqkNe6jxYg/I2QudT+PlGgw
HwYDVR0jBBgwFoAUYxvp8EqkNe6jxYg/I2QudT+PlGgwDwYDVR0TAQH/BAUwAwEB
/zANBgkqhkiG9w0BAQsFAAOCAQEAe5rKAJmANobV68PFFca6VtNPIXpDVDgmT/A1
ulYUS9XI5/zWDtpiCaxAKz67YJLMG1547oKAEqmhtNVw72orafm50PWV+50YnWJW
DHnpOp+FCnkTY946+3gKAKtFTIIWo0wNiIGZNcdty/9FM8voUGxcC3PiI90MRnk9
dUySU3HIp6ozWjcbzFBYCE76vxOE7gNy++Y4/Ma+pp2fvMS2crnnb5DVqBw2jzj9
vxTQxSyJlWC2LXrV4e0CHv0rwBM7DIOlcc9yNEdHVwogDsffZW/j7gF+82GZ68hk
qNBsNeKXV2h42GEfE+MlfxQwt3MbqcH4drqLEB0NovU2Gl+OMA==
-----END CERTIFICATE-----`))
	c, err := x509.ParseCertificate(b.Bytes)
	if err != nil {
		panic(err)
	}
	return c
}()

const oktaMetadata = `<?xml version="1.0" encoding="UTF-8"?><md:EntityDescriptor entityID="http://www.okta.com/exkcp3hvhcvnSEOPe697" xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"><md:IDPSSODescriptor WantAuthnRequestsSigned="false" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"><md:KeyDescriptor use="signing"><ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:X509Data><ds:X509Certificate>MIIDqjCCApKgAwIBAgIGAY57e06zMA0GCSqGSIb3DQEBCwUAMIGVMQswCQYDVQQGEwJVUzETMBEG
A1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzENMAsGA1UECgwET2t0YTEU
MBIGA1UECwwLU1NPUHJvdmlkZXIxFjAUBgNVBAMMDXRyaWFsLTIxNzE2MDUxHDAaBgkqhkiG9w0B
CQEWDWluZm9Ab2t0YS5jb20wHhcNMjQwMzI2MTU1NjQyWhcNMzQwMzI2MTU1NzQyWjCBlTELMAkG
A1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTAL
BgNVBAoMBE9rdGExFDASBgNVBAsMC1NTT1Byb3ZpZGVyMRYwFAYDVQQDDA10cmlhbC0yMTcxNjA1
MRwwGgYJKoZIhvcNAQkBFg1pbmZvQG9rdGEuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEAqN9uy+3t2JDPmAL6K5xN3wKlMviU6WhHORDzhiU+88xkwaxZPn+cJKRDPPzpX+Pfn0T3
EGrqDHygrK6T1C5ObmzxPe8B6V1A4sajZSxDCkcBMZiSsjSESWf9wSq59VaSVWAl6SgAXr70MyUe
q7+zgszjUyo5aTchiPAyV2fd+Kxx+ioFuFC8QzxHm+YIEA0QTYE8Ki1MEPAHiG3jJ8VxjmtwTZp3
Vc3Q//DzkSE3ALuRDK3SgfVQ56mtKDL5uWVs7wXZf0vYkcERJqJ/0UY/IqVAjxQwOt0z3fJ1vU9d
EPtlB84tclL9srdMfoOPNir8gqmxTB44uFKEPD+3Vzmr4QIDAQABMA0GCSqGSIb3DQEBCwUAA4IB
AQAdvPKjnUfiashhotsgu09Hv1Yv5+4Y+z+88zMG+5s1sCEzim0UuhDfoAbT+9EcyZ3/44xT9kKy
VhsH7UTeG1Qh8+dosxyPssQYIx1/iFzh9DAWC8LbMoIJE01hfi+jCJ8HLTv+965J+S1cj5IFt2E5
DvBPTHFXmnB/XXrXgILuH+UuSzpBOl+bwuNMeuoeFsXBRgFG0a7j4jtuU8u7Qkr7U/qoAvjDVjdc
pi0jAeAenOEmNm7yppMb0mduj05twiI8wlnnPoqDMz8teEaJ+egF3eCINFugt6JlRrBQJabIut/G
Dw9b9RdRUuLeme+8WFKTfd0flvzYT0gxoWaEPpes</ds:X509Certificate></ds:X509Data></ds:KeyInfo></md:KeyDescriptor><md:NameIDFormat>urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress</md:NameIDFormat><md:SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="https://trial-2171605.okta.com/app/trial-2171605_fleetmfa_1/exkcp3hvhcvnSEOPe697/sso/saml"/><md:SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="https://trial-2171605.okta.com/app/trial-2171605_fleetmfa_1/exkcp3hvhcvnSEOPe697/sso/saml"/></md:IDPSSODescriptor></md:EntityDescriptor>`

func getSP() saml.ServiceProvider {
	u, err := url.Parse("http://" + addr)
	if err != nil {
		panic(err)
	}

	meta, err := samlsp.ParseMetadata([]byte(oktaMetadata))
	if err != nil {
		panic(err)
	}

	samlSP := samlsp.DefaultServiceProvider(samlsp.Options{
		URL:         *u,
		Key:         spKey,
		Certificate: spCert,
		IDPMetadata: meta,
	})

	return samlSP
}

// We don't actually need to maintain sessions like in a typical service provider scenario.
// Implementing a basically "empty" session provider to use in the middleware. In a production
// implementation we might want to not use the middleware at all, but instead extract the relevant pieces.
type emptySessionProvider struct{}

func (e emptySessionProvider) CreateSession(w http.ResponseWriter, r *http.Request, assertion *saml.Assertion) error {
	return nil
}

func (e emptySessionProvider) DeleteSession(w http.ResponseWriter, r *http.Request) error {
	return nil
}

func (e emptySessionProvider) GetSession(r *http.Request) (samlsp.Session, error) {
	return nil, samlsp.ErrNoSession
}

func NewSPMiddleware() *samlsp.Middleware {
	m := &samlsp.Middleware{
		ServiceProvider: getSP(),
		Binding:         "",
		ResponseBinding: saml.HTTPPostBinding,
		OnError:         samlsp.DefaultOnError,
		Session:         emptySessionProvider{},
	}
	m.RequestTracker = samlsp.DefaultRequestTracker(samlsp.Options{Key: spKey, URL: m.ServiceProvider.AcsURL}, &m.ServiceProvider)

	return m
}

/*
func makeServeResponse(m *samlsp.Middleware) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		err := r.ParseForm()
		if err != nil {
			m.OnError(w, r, err)
			return
		}

		possibleRequestIDs := []string{}
		if m.ServiceProvider.AllowIDPInitiated {
			possibleRequestIDs = append(possibleRequestIDs, "")
		}

		trackedRequests := m.RequestTracker.GetTrackedRequests(r)
		for _, tr := range trackedRequests {
			possibleRequestIDs = append(possibleRequestIDs, tr.SAMLRequestID)
		}

		assertion, err := m.ServiceProvider.ParseResponse(r, possibleRequestIDs)
		if err != nil {
			m.OnError(w, r, err)
			return
		}

		if trackedRequestIndex := r.Form.Get("RelayState"); trackedRequestIndex != "" {
			trackedRequest, err := m.RequestTracker.GetTrackedRequest(r, trackedRequestIndex)
			if err != nil {

					m.OnError(w, r, err)
					return
				}
			} else {
				if err := m.RequestTracker.StopTrackingRequest(w, r, trackedRequestIndex); err != nil {
					m.OnError(w, r, err)
					return
				}

				redirectURI = trackedRequest.URI
			}
		}
	}
}
*/
